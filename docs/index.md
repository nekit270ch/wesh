# Документация WESH

## Скачивание и установка
wesh представляет собой единственный файл - `wesh.exe` или `wesh_x86.exe` (в зависимости от разрядности).  

При запуске wesh сразу готов к работе, установка не требуется.  
Но если вы хотите ассоциировать файлы `.wesh` с wesh, а также добавить wesh в PATH,
вам понадобится выполнить следующую команду:  
`requestAdminPriv ; load setup`

## Синтаксис
> Внимание! Синтаксис wesh может быть изменен командами. Здесь представлен синтаксис по умолчанию.
### Общий синтаксис
Команды в wesh состоят из названия команды и аргументов, перечисленных через запятую и пробел:  
`команда [аргумент1][, аргумент2]...[, аргументN]`

Если в одной строке нужно выполнить несколько команд, их можно разделить символами ` ; ` (пробелы обязательны).  
Пример: `команда1 ; команда2`

Если в тексте аргумента требуется использовать символ `;`, перед ним необходимо поставить `\`.  
Пример: `команда1 'текст \; аргумента' ; команда2`
### Строки и блоки кода
Если в значении аргумента присутствует пробел или запятая, его необходимо взять в одинарные или двойные кавычки:
`команда 'аргумент 1', "аргумент 2"`

Блоки кода оформляются фигурными скобками:  
`команда { аргумент - блок кода }`

### Операторы
#### Синтаксис операторов
Операторы используются для вставки каких-либо данных в агрументы. В wesh есть операторы трех типов: блочные, внутристрочные и модифицирующие.  

Блочные операторы действуют только в пределах блока (он заключается в круглые скобки), и могут быть размещены в любой позиции.  
К ним относятся операторы `&(...)` и `%(...)`  
Пример: `writeln 'текст &(блок оператора) другой текст'`

Внутристрочные операторы похожи на блочные, но в них вместо блока используются определенные символы.  
Конец зоны действия таких операторов - первый не подходящий символ.  
К внутристрочным операторам отностится только оператор `@`, который принимает буквы английского алфавита, цифры, точки и нижние подчеркивания.  
Пример: `writeln 'текст @foo123 другой текст'`. В данном случае оператор заменит лишь строку `foo123`.

Модифицирующие операторы действуют на весь аргумент и могут находиться только в начале строки или перед кавычкой.  
К ним относятся операторы `&`, `%` и `~`.  
Пример: `команда &'оператор перед кавычкой', '%оператор в начале строки'`
#### Использование операторов
Оператор `@` используется для вставки в аргумент значения переменной.  
Пример: `writeln 'Значение переменной varName: @varName'`

Оператор `&` или `&(...)` используется для вставки в аргумент результата выполнения другой команды.  
Примеры: `writeln 'текст &(команда аргументы) другой текст'`, `writeln '&команда аргументы'`  
Если этот оператор используется в качестве модифицирующего, то вместо кавычек можно использовать фигурные скобки:  
`writeln &{ команда аргументы }`

Оператор `%` или `%(...)` используется для вставки в аргумент результата математического выражения.
Примеры: `writeln '2 + 2 * 2 = %(2 + 2 * 2)'`, `writeln '%2 + 2 * 2'`

Оператор `~` отменяет действие всех других операторов, что позволяет использовать символы `@`, `&` и `%` в тексте аргумента.  
Пример: `writeln ~'&Эта %(строка) @будет выведена без изменений'`
### Переменные
Названия переменных могут содержать только буквы английского алфавита, цифры и нижние подчеркивания.  

Для получения значения переменной используется оператор `@` или команда `var.get`

Для создания переменной или присвоения ей значения используется конструкция `имяПеременной = значение` 
(в значении допускается использование операторов), а также команды `set <имя переменной>, <значение>` или `var.set <имя переменной>, <значение>`
### Функции
Функции создаются с помощью команды `func`, а вызываются - командой `f`.

В функции можно передавать аргументы, в коде функции они будут доступны в виде переменных `#<номер аргумента>`.  
Пример:
```
func foo, { writeln 'Первый аргумент: @#1' \; writeln 'Второй аргумент: @#2' }
f foo, bar, baz
```
Данный код выведет в консоль:
```
Первый аргумент: bar
Второй аргумент: baz
```
### Объекты и массивы
Каждый объект или массив имеет ID. Также у объекта/массива может быть имя (имя объекта/массива - это переменная, содержащая его ID)

Для получения значения свойства объекта или массива используется оператор `@`: `@<имя объекта или массива>.<имя свойства/индекс>` 
или команды `obj.get <id объекта>, <имя свойства>` для объектов и `arr.get <id массива>, <индекс>` для массивов.

Для установки значения свойства объекта или массива используется конструкция `<имя объекта или массива>.<имя свойства>` 
или команды `obj.set <id объекта>, <имя свойства>, <значение>` для объектов и `arr.set <id массива>, <имя свойства/индекс>, <значение>` для массивов.

У массивов есть свойство `length`, в котором находится длина массива.
### Условия
Условия используются в командах `if`, `ife`, `while`, `for` и `foreachIf`.  
В них можно использовать любые операторы сравнения (`==`, `!=`, `<`, `<=`, `>`, `>=`), но строковые значения необходимо заключать в кавычки.  
Примеры: `if '@a < @b', { writeln 'a меньше b' }`, `if '"@str1" == "foo"', { writeln 'Содержимое сроки str1 - foo' }`
### Скрипты
Скрипты представляют собой текстовые файлы, содержащие команды wesh.  
В скрипты можно вставлять комментарии, начинающиеся с символа `#`. Также все пустые строки игнорируются.  

В скриптах можно использовать многострочные блоки кода, но каждую строку блока нужно завершать пробелом и точкой с запятой, 
а перед началом каждой команды должен стоять минимум 1 пробел или табуляция.  
Пример:
```
for i, 0, 10, { ;
  writeln 'Команда в блоке кода' ;
  writeln 'Еще одна команда в блоке кода' ;
}
```
### Встроенные переменные
`null` - константа `null`, обозначающая пустой результат.  
`error` - последнее сообщение об ошибке. Если ошибок не было, равняется `null`.  
`currDir` - текущая папка.  
`weshPath` - полный путь к исполняемому файлу wesh.  
`weshDir` - путь к папке расположения wesh.  
`modulesDir` - путь к папке с модулями.  
`modulesUrl` - ссылка на репозиторий модулей. Строка `MODULE_NAME` заменяется именем модуля.
## Команды
### Общие команды
`exit` - выйти из оболочки.

`echo <строка>` - вернуть указанную строку.

`exec <команда>` - выполнить команду.

`. <выражение>` - вычислить математическое выражение.

`rand <минимум>, <максимум>` - выдать случайное целое число в указанном диапазоне.

`wait <задержка>` - ждать указанное количество миллисекунд.

`requestAdminPriv` - запросить права администратора. Если они уже получены, ничего не делать.
### Консоль
`write <строка>` - вывести строку в консоль.

`writeln <строка>` - вывести строку в консоль и перейти на новую строку.

`readln <приглашение>` - вывести приглашение в консоль, после чего запросить у пользователя ввод строки в консоль.

`clear` - очистить консоль.

`title <заголовок>` - установить заголовок окна консоли.
### Переменные
`set <имя переменной>, <значение>` или `var.set <имя переменной>, <значение>` - создать переменную или присвоить ей значение.

`sete <имя переменной>, <блок кода>` - присвоить переменной результат выполнения блока кода.

`var.get <имя переменной>` - получить значение переменной.

`var.delete <имя переменной>` - удалить переменную.

`var.list` - вывести имена всех переменных.

`const <имя переменной>` - сделать переменную константой (ее значение нельзя будет изменить).
### Условия и циклы
`if <условие>, <блок кода 1>, <блок кода 2>` - если условие истинно, выполнить блок кода 1, иначе - блок кода 2.

`ife <блок кода 1>, <блок кода 2>, <блок кода 3>` - если результат выполнения блока кода 1 - `true`, выполнить блок кода 2, иначе - блок кода 3.

`while <условие>, <блок кода>` - пока условие истинно, выполнять блок кода.

`for <имя переменной>, <начальное значение>, <конечное значение>, <блок кода>` - выполнять блок кода, пока значение переменной меньше максимального значения. Переменная создается автоматически и доступна в блоке кода.

`foreach <блок кода 1>, <блок кода 2>` - выполнять блок кода 2 для каждой строки результата выполнения блока кода 1. В блоке кода 2 доступна переменная `s`, в которой находится текущая строка.

`foreachIf <блок кода 1>, <блок кода 2>, <блок кода 3>` - выполнять блок кода 3 для каждой строки результата выполнения блока кода 1, если результат выполнения блока кода 2 - `true`. В блоках кода 2 и 3 доступна переменная `s`, в которой находится текущая строка.
### Функции
`func <название функции>, <блок кода>` - создать функцию.

`f <название функции>[, <аргумент 1>][, <аргумент 2>]...[, <аргумент N>]` - вызвать функцию.
### Объекты
`obj.create <имя объекта>` - создать объект.

`obj.createN <id объекта>` - создать объект с указанным ID.

`obj.get <id объекта>, <имя свойства>` - получить значение свойства объекта.

`obj.set <id объекта>, <имя свойства>, <значение>` - установить значение свойства объекта.

`obj.foreach <id объекта>, <блок кода>` - выполнять блок кода для каждого свойства в объекте. В блоке кода доступны переменные `k` и `v`, содержащие имя свойства и его значение.

`obj.getKeys <id объекта>` - вывести все свойства объекта.

`obj.getData <id объекта>` - вывести все свойства объекта и их значения.

`obj.save <id объекта>, <имя файла>` - сохранить объект в файл.

`obj.load <id объекта>, <имя файла>` - загрузить объект из файла.
### Массивы
`arr.create <элемент 1>[, <элемент 2>]...[, <элемент N>]` - создать массив из указанных элементов. Возвращает ID массива.

`arr.get <id массива>, <индекс>` - получить знаение элемента массива.

`arr.set <id массива>, <индекс>, <значение>` - установить значение элемента массива.

`arr.push <id массива>, <элемент>` - добавить в конец массива новый элемент. Возвращает длину массива.

`arr.pop <id массива>` - удалить последний элемент массива. Возвращает удаленный элемент.

`arr.shift <id массива>` - удалить первый элемент массива. Возвращает удаленный элемент.

`arr.insert <id массива>, <индекс>, <элемент>` - вставить в массив новый элемент. Возвращает вставленный элемент.
### Строки
`str.equals <строка 1>, <строка 2>` - определить, равны ли строки.

`str.contains <строка 1>, <строка 2>` - определить, содержится ли в строке 1 строка 2.

`str.isMatch <строка>, <регулярное выражение>` - определить, соответствует ли строка регулярному выражению.

`str.indexOf <строка>, <символ>` - определить, на какой позиции находится символ в строке.

`str.replace <строка>, <искомая строка>, <замещающая строка>` - заменить все вхождения в строку искомой строки на замещающую строку.
### Команды
`cmd.list` - вывести все доступные команды.

`cmd.alias <псевдоним>, <имя команды>` - создать псевдоним для команды.

`cmd.fromFunc <имя команды>, <имя функции>` - превратить функцию в команду.
### Модули
`load <модуль 1>[, <модуль 2>]...[, <модуль N>]` - загрузить модули. В качестве имени модуля может использоваться полный путь к файлу, ссылка на файл модуля в Интернете или имя модуля в репозитории.

`module.install <имя модуля>` - установить модуль из репозитория.

`module.uninstall <имя модуля>` - удалить модуль.
### Изменение синтаксиса
`lang.list` - вывести текущие настройки синтаксиса.

`lang.get <элемент>` - получить значение элмента синтаксиса.

`lang.set <элемент>, <значение>` - установить значение элемента синтаксиса.
### Файловая система
`fs.readFile <путь к файлу>` - прочитать файл.

`fs.writeFile <путь к файлу>, <текст>` - записать текст в файл.

`fs.copyFile <путь к файлу>, <новый путь>` - скопировать файл.

`fs.moveFile <путь к файлу>, <новый путь>` - переместить файл.

`fs.deleteFile <путь к файлу>` - удалить файл.

`fs.fileExists <путь к файлу>` - проверить, существует ли файл.

`fs.fileInfo <путь к файлу>` - создать объект со свойствами файла и вернуть его ID.

`cd <путь к папке>` - сменить текущую папку.

`fs.createDir <путь к папке>` - создать папку.

`fs.moveDir <путь к папке>, <новый путь>` - переместить папку.

`fs.deleteDir <путь к папке>` - удалить папку.

`fs.listDir [<путь к папке>]` - вывести содержимое папки. Если путь не указан, используется текущая папка.

`fs.dirExists <путь к папке>` - проверить, существует ли папка.

`fs.dirInfo <путь к папке>` - создать объект со свойствами папки и вернуть его ID.
