# Документация WESH

## Скачивание и установка
wesh представляет собой единственный файл - `wesh.exe` или `wesh_x86.exe` (в зависимости от разрядности).  

При запуске wesh сразу готов к работе, установка не требуется.  
Но если вы хотите ассоциировать файлы `.wesh` с wesh, а также добавить wesh в PATH,
вам понадобится выполнить команду `load setup` с правами администратора.

## Синтаксис
> Внимание! Синтаксис wesh может быть изменен командами. Здесь представлен синтаксис по умолчанию.

### Общий синтаксис
Команды в wesh состоят из названия команды и аргументов, перечисленных через запятую и пробел:  
`команда [аргумент1][, аргумент2]...[, аргументN]`

Если в одной строке нужно выполнить несколько команд, их можно разделить символами ` ; ` (пробелы обязательны).  
Пример: `команда1 ; команда2`

Если в тексте аргумента требуется использовать символ `;`, `{` или `}`, перед ним необходимо поставить `\`.  
Пример: `команда1 'текст \; аргумента' ; команда2`
### Строки и блоки кода
Если в значении аргумента присутствует пробел или запятая, его необходимо взять в одинарные или двойные кавычки:
`команда 'аргумент 1', "аргумент 2"`

Блоки кода оформляются фигурными скобками:  
`команда { аргумент - блок кода }`

### Операторы
#### Синтаксис операторов
Операторы используются для вставки каких-либо данных в агрументы. В wesh есть операторы трех типов: блочные, внутристрочные и модифицирующие.  

Блочные операторы действуют только в пределах блока (он заключается в круглые скобки), и могут быть размещены в любой позиции.  
К ним относятся операторы `&(...)`, `%(...)` и `@(...)`  
Пример: `writeln 'текст &(блок оператора) другой текст'`

Внутристрочные операторы похожи на блочные, но в них вместо блока используются определенные символы.  
Конец зоны действия таких операторов - первый не подходящий символ.  
К внутристрочным операторам отностится только оператор `@`, который принимает буквы английского алфавита, цифры, точки и нижние подчеркивания.  
Пример: `writeln 'текст @foo123 другой текст'`. В данном случае оператор заменит лишь строку `foo123`.

Модифицирующие операторы действуют на весь аргумент и могут находиться только в начале строки или перед кавычкой.  
К ним относятся операторы `&`, `%`, `@` и `~`.  
Пример: `команда &'оператор перед кавычкой', '%оператор в начале строки'`
#### Использование операторов
Оператор `@` или `@(...)` используется для вставки в аргумент значения переменной.  
Пример: `writeln 'Значение переменной varName: @varName'`

Оператор `&` или `&(...)` используется для вставки в аргумент результата выполнения другой команды.  
Примеры: `writeln 'текст &(команда аргументы) другой текст'`, `writeln '&команда аргументы'`  
Если этот оператор используется в качестве модифицирующего, то вместо кавычек можно использовать фигурные скобки:  
`writeln &{ команда аргументы }`

Оператор `%` или `%(...)` используется для вставки в аргумент результата математического выражения.
Примеры: `writeln '2 + 2 * 2 = %(2 + 2 * 2)'`, `writeln '%2 + 2 * 2'`

Оператор `~` отменяет действие всех других операторов, что позволяет использовать символы `@`, `&` и `%` в тексте аргумента.  
Пример: `writeln ~'&Эта %(строка) @будет выведена без изменений'`
### Переменные
Названия переменных могут содержать только буквы английского алфавита, цифры и нижние подчеркивания.  

Для получения значения переменной используется оператор `@` или команда `var.get`

Для создания переменной или присвоения ей значения используется конструкция `имяПеременной = значение` (в значении допускается использование операторов) 
или `имяПеременной <оператор>= значение` (в этом случае оператор действует на все значение), а также команды `set <имя переменной>, <значение>` или `var.set <имя переменной>, <значение>`
### Функции
Функции создаются с помощью команды `func`, а вызываются - командой `f`.

В функции можно передавать аргументы, в коде функции они будут доступны в массиве `funcArgs`.    
Пример:
```
func foo, { writeln 'Первый аргумент: @funcArgs.0' \; writeln 'Второй аргумент: @funcArgs.1' }
f foo, bar, baz
```
Данный код выведет в консоль:
```
Первый аргумент: bar
Второй аргумент: baz
```
### Объекты и массивы
Каждый объект или массив имеет ID. Также у объекта/массива может быть имя (имя объекта/массива - это переменная, содержащая его ID)

Для получения значения свойства объекта или массива используется оператор `@`: `@<имя объекта или массива>.<имя свойства/индекс>` 
или команды `obj.get <id объекта>, <имя свойства>` для объектов и `arr.get <id массива>, <индекс>` для массивов.

Для установки значения свойства объекта или массива используется конструкция `<имя объекта или массива>.<имя свойства>` 
или команды `obj.set <id объекта>, <имя свойства>, <значение>` для объектов и `arr.set <id массива>, <имя свойства/индекс>, <значение>` для массивов.

У массивов есть свойство `length`, в котором находится длина массива.
### Условия
Условия используются в командах `if`, `ife`, `while`, `for`, `foreach` и `foreachIf`.  
В них можно использовать любые операторы сравнения (`==`, `!=`, `<`, `<=`, `>`, `>=`), но строковые значения необходимо заключать в кавычки.  
Примеры: `if '@a < @b', { writeln 'a меньше b' }`, `if '"@str1" == "foo"', { writeln 'Содержимое сроки str1 - foo' }`
### Скрипты
Скрипты представляют собой текстовые файлы, содержащие команды wesh.  
В скрипты можно вставлять комментарии, начинающиеся с символа `#`. Также все пустые строки игнорируются.  

В скриптах можно использовать многострочные блоки кода.
Пример:
```
for i, 0, 10, {
  writeln 'Команда в блоке кода'
  writeln 'Еще одна команда в блоке кода'
}
```
### Встроенные переменные
`null` - константа `null`, обозначающая пустой результат.  
`error` - последнее сообщение об ошибке. Если ошибок не было, равняется `@null`.  
`errorAction` - действие при ошибке. Если равно `none`, ошибки будут игнорироваться, если `print`, ошибки будут выводиться в консоль, если `msgbox` - ошибки будут выводиться в окне сообщения. Также можно указать функцию-обработчик ошибок, если присвоить этой переменной значение `func:<имя функции>`.  
`newLine` - символы новой строки (\r\n).  
`currDir` - текущая папка.  
`weshPath` - полный путь к исполняемому файлу wesh.  
`weshDir` - путь к папке расположения wesh.  
`modulesDir` - путь к папке с модулями.  
`modulesUrl` - ссылка на репозиторий модулей. Строка `MODULE_NAME` заменяется именем модуля.
#### Встроенные переменные в скриптах
`scriptPath` - полный путь к скрипту.  
`scriptDir` - путь к папке скрипта.  
`scriptArgs` - массив аргументов скрипта.  
## Команды
### Общие команды
`exit` - выйти из оболочки.

`echo <строка>` - вернуть указанную строку.

`exec <команда>` - выполнить команду.

`. <выражение>` - вычислить математическое выражение.

`rand <минимум>, <максимум>` - выдать случайное целое число в указанном диапазоне.

`wait <задержка>` - ждать указанное количество миллисекунд.

`requestAdminPriv` - запросить права администратора. Если они уже получены, ничего не делать.
### Консоль
`write <строка>` - вывести строку в консоль.

`writeln <строка>` - вывести строку в консоль и перейти на новую строку.

`readln <приглашение>` - вывести приглашение в консоль, после чего запросить у пользователя ввод строки в консоль.

`clear` - очистить консоль.

`title <заголовок>` - установить заголовок окна консоли.
### Переменные
`set <имя переменной>, <значение>` или `var.set <имя переменной>, <значение>` - создать переменную или присвоить ей значение.

`sete <имя переменной>, <блок кода>` - присвоить переменной результат выполнения блока кода.

`var.get <имя переменной>` - получить значение переменной.

`var.delete <имя переменной>` - удалить переменную.

`var.list` - вывести имена всех переменных.

`const <имя переменной>` - сделать переменную константой (ее значение нельзя будет изменить).
### Условия и циклы
`if <условие>, <блок кода 1>, <блок кода 2>` - если условие истинно, выполнить блок кода 1, иначе - блок кода 2.

`ife <блок кода 1>, <блок кода 2>, <блок кода 3>` - если результат выполнения блока кода 1 - `true`, выполнить блок кода 2, иначе - блок кода 3.

`while <условие>, <блок кода>` - пока условие истинно, выполнять блок кода.

`for <имя переменной>, <начальное значение>, <прирост>, <конечное значение>, <блок кода>` - выполнять блок кода, пока значение переменной меньше максимального значения. Переменная создается автоматически и доступна в блоке кода.

`foreach <блок кода 1>, <блок кода 2>` - выполнять блок кода 2 для каждой строки результата выполнения блока кода 1. В блоке кода 2 доступна переменная `s`, в которой находится текущая строка.

`foreachIf <блок кода 1>, <блок кода 2>, <блок кода 3>` - выполнять блок кода 3 для каждой строки результата выполнения блока кода 1, если результат выполнения блока кода 2 - `true`. В блоках кода 2 и 3 доступна переменная `s`, в которой находится текущая строка.
### Функции
`func <название функции>, <блок кода>` - создать функцию.

`f <название функции>[, <аргумент 1>][, <аргумент 2>]...[, <аргумент N>]` - вызвать функцию.
### Объекты
`obj.create <имя объекта>` - создать объект.

`obj.createN <id объекта>` - создать объект с указанным ID.

`obj.get <id объекта>, <имя свойства>` - получить значение свойства объекта.

`obj.set <id объекта>, <имя свойства>, <значение>` - установить значение свойства объекта.

`obj.foreach <id объекта>, <блок кода>` - выполнять блок кода для каждого свойства в объекте. В блоке кода доступны переменные `k` и `v`, содержащие имя свойства и его значение.

`obj.getKeys <id объекта>` - вывести все свойства объекта.

`obj.getData <id объекта>` - вывести все свойства объекта и их значения.

`obj.save <id объекта>, <имя файла>` - сохранить объект в файл.

`obj.load <id объекта>, <имя файла>` - загрузить объект из файла.
### Массивы
`arr.create <элемент 1>[, <элемент 2>]...[, <элемент N>]` - создать массив из указанных элементов. Возвращает ID массива.

`arr.get <id массива>, <индекс>` - получить знаение элемента массива.

`arr.set <id массива>, <индекс>, <значение>` - установить значение элемента массива.

`arr.push <id массива>, <элемент>` - добавить в конец массива новый элемент. Возвращает длину массива.

`arr.pop <id массива>` - удалить последний элемент массива. Возвращает удаленный элемент.

`arr.shift <id массива>` - удалить первый элемент массива. Возвращает удаленный элемент.

`arr.insert <id массива>, <индекс>, <элемент>` - вставить в массив новый элемент. Возвращает вставленный элемент.

`barr.readFromFile <имя файла>` - прочитать файл в бинарном режиме и сохранить в массив байт. Возвращает ID массива.

`barr.writeToFile <id массива>, <имя файла>` - записать массив байт в файл.
### Строки
`str.equals <строка 1>, <строка 2>` - определить, равны ли строки.

`str.contains <строка 1>, <строка 2>` - определить, содержится ли в строке 1 строка 2.

`str.isMatch <строка>, <регулярное выражение>` - определить, соответствует ли строка регулярному выражению.

`str.indexOf <строка>, <символ>` - определить, на какой позиции находится символ в строке.

`str.replace <строка>, <искомая строка>, <замещающая строка>[, <использовать regex>]` - заменить все вхождения в строку искомой строки на замещающую строку. Если `использовать regex` - `true`, искомая строка интерпретируется как регулярное выражение.

`str.concat <строка 1>[, <строка 2>]...[, <строка N>]` - объединить строки в одну.

`str.charAt <строка>, <позиция>` - вернуть символ, находящийся на указанной позиции в строке.
### Команды
`cmd.list` - вывести все доступные команды.

`cmd.alias <псевдоним>, <имя команды>` - создать псевдоним для команды.

`cmd.fromFunc <имя команды>, <имя функции>` - превратить функцию в команду.
### Модули
`load <модуль 1>[, <модуль 2>]...[, <модуль N>]` - загрузить модули. В качестве имени модуля может использоваться полный путь к файлу, ссылка на файл модуля в Интернете или имя модуля в репозитории.

`module.install <имя модуля>` - установить модуль из репозитория.

`module.uninstall <имя модуля>` - удалить модуль.
### Изменение синтаксиса
`lang.list` - вывести текущие настройки синтаксиса.

`lang.get <элемент>` - получить значение элмента синтаксиса.

`lang.set <элемент>, <значение>` - установить значение элемента синтаксиса.
### Файловая система
`fs.readFile <путь к файлу>` - прочитать файл.

`fs.writeFile <путь к файлу>, <текст>` - записать текст в файл.

`fs.copyFile <путь к файлу>, <новый путь>` - скопировать файл.

`fs.moveFile <путь к файлу>, <новый путь>` - переместить файл.

`fs.deleteFile <путь к файлу>` - удалить файл.

`fs.fileExists <путь к файлу>` - проверить, существует ли файл.

`fs.fileInfo <путь к файлу>` - создать объект со свойствами файла и вернуть его ID.

`cd <путь к папке>` - сменить текущую папку.

`fs.createDir <путь к папке>` - создать папку.

`fs.moveDir <путь к папке>, <новый путь>` - переместить папку.

`fs.deleteDir <путь к папке>` - удалить папку.

`fs.listDir [<путь к папке>]` - вывести содержимое папки. Если путь не указан, используется текущая папка.

`fs.dirExists <путь к папке>` - проверить, существует ли папка.

`fs.dirInfo <путь к папке>` - создать объект со свойствами папки и вернуть его ID.
### Реестр
`reg.createKey <раздел>, <имя нового раздела>` - создать новый раздел в указанном разделе реестра.

`reg.deleteKey <раздел>, <имя удаляемого раздела>` - удалить раздел в указанном разделе реестра.

`reg.list <раздел>` - вывести все подразделы и параметры указанного раздела реестра.

`reg.read <раздел>, <имя параметра>` - прочитать значение параметра реестра.

`reg.write <раздел>, <имя параметра>, <значение>` - установить значение параметра реестра.

`reg.delete <раздел>, <имя параметра>` - удалить параметр из раздела реестра.
### Управление процессами
`proc.run <имя процесса>[, <аргументы>][, <читать stdout>][, <стиль окна>][, <verb>]` - запустить процесс с указанным именем файла и аргументами. Если `читать stdout` - `true`, вернуть данные из StdOut процесса. Допустимые значения для стиля окна - `hidden`, `normal`, `minimized` и `maximized`. Если `verb` указан, использовать его.

`proc.kill <имя процесса>` - завершить процесс.

`proc.list` - вывести все выполняющиеся процессы.

`proc.getInfo <имя процесса>` - создать объект со свойствами процесса и вернуть его ID.
### Переменные окружения
`env.get <имя переменной>[, <тип>]` - получить значение переменной окружения. Если тип указан и равен `true`, использовать системную переменную, иначе - пользовательскую.

`env.set <имя переменной>, <значение>[, <тип>]` - установить значение переменной окружения. Если тип указан и равен `true`, использовать системную переменную, иначе - пользовательскую.
### HTTP
`http.request <метод>, <URL>[, <тело>]` - выполнить HTTP-запрос и вернуть результат. Доступные методы: `get` и `post`. При использовании метода `post` можно указать тело запроса.

`http.downloadFile <URL>, <путь к файлу>` - скачать файл.

`http.server <путь к папке>, <порт>` - запустить локальный HTTP-сервер с содержимым указанной папки.
### Автоматизация
`proc.activate <имя процесса>` - активировать процесс.

`proc.sendKeys <клавиши>` - отправить активному процессу нажатия клавиш.

`mouse.getPos` - создать объект с расположением курсора мыши и вернуть его ID.

`mouse.setPos <x>, <y>` - переместить курсор мыши.

`mouse.click [<кнопка>][, <время>]` - выполнить клик мышью. Допустимые значения кнопки: `left`, `right` и `middle`. По умолчанию - `left`. Время по умолчанию - 10 мс. Если время = 0, не отпускать кнопку.

`hotkey.set <клавиша>, <ctrl>, <alt>, <блок кода>` - задать выполнение блока кода при нажатии указанной комбинации клавиш. `ctrl` и `alt` могут принимать значения `true` и `false`. Если одно из них равно `true`, блок кода выполнится только при нажатии этой клавиши-модификатора одновременно с основной.

`hotkey.setKeyHandler <блок кода>` - задать выполнение блока кода при нажатии любой клавиши. В блоке кода доступна переменная `key`, содержащая нажатую клавишу.

`hotkey.listen` - запустить цикл прослушивания нажатий клавиш.
### GUI
`msgbox <сообщение>[, <заголовок>][, <кнопки>][, <иконка>]` - отобразить окно сообщения. Допустимые значения кнопок: `ok`, `okCancel`, `yesNo`, `yesNoCancel`, `abortRetryIgnore`, `retryCancel`. Допустимые значения иконки: `none`, `info`, `error`, `warning`, `question`. Возвращает одно из следующих значений в зависимости от выбора пользователя: `none`, `ok`, `cancel`, `yes`, `no`, `abort`, `retry`, `ignore`.

`inputbox <сообщение>, <заголовок>, <текст по умолчанию>` - отобразить окно ввода строки. Возвращает указанную пользователем строку.

`gui.openFileDialog <фильтр>[, <заголовок>][, <папка>]` - открыть диалоговое окно открытия файла и вернуть путь к выбранному пользователем файлу.

`gui.saveFileDialog <фильтр>[, <заголовок>][, <папка>]` - открыть диалоговое окно сохранения файла и вернуть путь к выбранному пользователем файлу.

`gui.createForm <заголовок>, <длина>, <ширина>[, <фиксированный размер>]` - создать форму и вернуть ее ID.

`gui.showForm <id формы>` - отобразить форму.

`gui.createElem <тип>` - создать элемент GUI и вернуть его ID. Допустимые типы: `panel`, `label`, `button`, `textbox`, `checkbox`, `combobox`.

`gui.getElemProp <id формы/элемента>, <имя свойства>` - получить значение свойства элемента или формы. Допустимые свойства: `text`, `x`, `y`, `width`, `height`, `color` (в формате `R,G,B`), bgcolor (в формате `R,G,B`), `checked` (только для `checkbox`), `multiline` (только для `textbox`).

`gui.setElemProp <id формы/элемента>, <имя свойства>, <значение>` - установить значение свойства элемента или формы. Допустимые свойства: `text`, `x`, `y`, `width`, `height`, `color` (в формате `R,G,B`), bgcolor (в формате `R,G,B`), `checked` (только для `checkbox`), `multiline` (только для `textbox`).

`gui.setFont <id формы/элемента>, <имя шрифта>, <размер шрифта>` - установить шрифт элемента или формы.

`gui.addEvent <id формы/элемента>, <тип события>, <блок кода>` - добавить обработчик события для элемента или формы. Допустимые типы: `click` и `keydown`. Если тип - `keydown`, в блоке кода доступна переменная `key`, содержащая нажатую клавишу.

`gui.addElem <id формы/панели>, <id элемента>` - добавить элемент в форму/на панель.
### Win32
`win32.getHandle <значение>` - получить дескриптор окна по его числовому значению (полученному, например, из Spy++).

`win32.getHandleValue <дескриптор>` - получить числовое значение дескриптора окна.

`win32.findWindow <класс>, <текст>` - найти окно по классу или тексту. Возвращает ID дескриптора окна. Класс или текст могут быть равны `@null`. Подробнее: [FindWindow](https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-findwindowa)

`win32.findChildWindow <дескриптор родительского окна>, <класс>, <текст>` - ищет дочернее окно. Возвращает ID дескриптора окна. Класс или текст могут быть равны `@null`. Подробнее: [FindWindowEx](https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-findwindowexa)

`win32.getForegroundWindow` - возвращает ID дескриптора активного окна.

`win32.sendMessage <дескриптор>, <сообщение>, <wParam>, <lParam>` - отправить сообщение окну. Подробнее: [SendMessage](https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-sendmessage)

`win32.getWindowText <дескриптор окна>` - получить текст из указанного окна.

`win32.setWindowText <дескриптор окна>, <текст>` - задает текст в указанном окне.
### Буфер обмена
`clipboard.get` - получить текст из буфера обмена.

`clipboard.set <текст>` - вставить текст в буфер обмена.
### ZIP-архивы
`zip.create <папка>, <zip-файл>` - упаковать указанную папку в ZIP-файл.

`zip.extract <zip-файл>, <папка>` - распаковать ZIP-файл в указанную папку.
