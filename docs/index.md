# Документация WESH

## Скачивание и установка
wesh представляет собой единственный файл - `wesh.exe` или `wesh_x86.exe` (в зависимости от разрядности).  

При запуске wesh сразу готов к работе, установка не требуется.  
Но если вы хотите ассоциировать файлы `.wesh` с wesh, а также добавить wesh в PATH,
вам понадобится выполнить команду `load setup` с правами администратора.

## Синтаксис
> Внимание! Синтаксис wesh может быть изменен командами. Здесь представлен синтаксис по умолчанию.

### Общий синтаксис
Команды в wesh состоят из названия команды и аргументов, перечисленных через запятую и пробел:  
`команда [аргумент1][, аргумент2]...[, аргументN]`

Если в одной строке нужно выполнить несколько команд, их можно разделить символами ` ; ` (пробелы обязательны).  
Пример: `команда1 ; команда2`

Если в тексте аргумента требуется использовать символ `;`, `{` или `}`, перед ним необходимо поставить `\`.  
Пример: `команда1 'текст \; аргумента' ; команда2`
### Строки и блоки кода
Если в значении аргумента присутствует пробел или запятая, его необходимо взять в одинарные или двойные кавычки:
`команда 'аргумент 1', "аргумент 2"`

Блоки кода оформляются фигурными скобками:  
`команда { аргумент - блок кода }`

### Операторы
#### Синтаксис операторов
Операторы используются для вставки каких-либо данных в агрументы. В wesh есть операторы трех типов: блочные, внутристрочные и модифицирующие.  

Блочные операторы действуют только в пределах блока (он заключается в круглые или квадратные скобки), и могут быть размещены в любой позиции.  
К ним относятся операторы `&(...)`, `%(...)` и `@(...)`  
Пример: `writeln 'текст &(блок оператора) другой текст'`

Примечание: при использовании круглых скобок внутри блока (например, в математических выражениях) необходимо использовать квадратные скобки.  
Пример: `writeln 'Решение: %[2 + 4 * (12 - 7)]'`

Внутристрочные операторы похожи на блочные, но в них вместо блока используются определенные символы.  
Конец зоны действия таких операторов - первый неподходящий символ.  
К внутристрочным операторам относится только оператор `@`, который принимает буквы английского алфавита, цифры, точки и нижние подчеркивания.  
Пример: `writeln 'текст @foo123 другой текст'`. В данном случае оператор заменит лишь строку `foo123`.

Модифицирующие операторы действуют на весь аргумент и могут находиться только в начале строки или перед кавычкой.  
К ним относятся операторы `&`, `%`, `@` и `~`.  
При использовании модифицирующих операторов дальнейший разбор строки не происходит.  
Пример: `команда &'оператор перед кавычкой', '%оператор в начале строки'`
#### Использование операторов
Оператор `@` или `@(...)` используется для вставки в аргумент значения переменной.  
Пример: `writeln 'Значение переменной varName: @varName'`

Оператор `&` или `&(...)` используется для вставки в аргумент результата выполнения другой команды.  
Примеры: `writeln 'текст &(команда аргументы) другой текст'`, `writeln '&команда аргументы'`  
Если этот оператор используется в качестве модифицирующего, то вместо кавычек можно использовать фигурные скобки:  
`writeln &{ команда аргументы }`

Оператор `%` или `%(...)` используется для вставки в аргумент результата математического выражения.
Примеры: `writeln '2 + 2 * 2 = %(2 + 2 * 2)'`, `writeln '%2 + 2 * 2'`

Оператор `~` отменяет действие всех других операторов, что позволяет использовать символы `@`, `&` и `%` в тексте аргумента.  
Пример: `writeln ~'&Эта %(строка) @будет выведена без изменений'`
### Переменные
Названия переменных могут содержать только буквы английского алфавита, цифры и нижние подчеркивания.  

Для получения значения переменной используется оператор `@` или команда `var.get`

Для создания переменной или присвоения ей значения используется конструкция `имяПеременной = значение` (в значении допускается использование операторов) 
или `имяПеременной =оператор значение` (в этом случае оператор действует на все значение), а также команды `set <имя переменной>, <значение>` или `var.set <имя переменной>, <значение>`
### Функции
Функции создаются с помощью команды `func` или `afunc`, а вызываются как команды или командой `f`.

В функции можно передавать аргументы, в коде функции они будут доступны в массиве `funcArgs`.
Пример:
```
func foo, { writeln 'Первый аргумент: @funcArgs.0' \; writeln 'Второй аргумент: @funcArgs.1' }
foo bar, baz
# или: f foo, bar, baz
```
Данный код выведет в консоль:
```
Первый аргумент: bar
Второй аргумент: baz
```

Команда `afunc` создает анонимную функцию со случайным именем и возвращает его.  
Анонимные функции можно вызвать либо командой `f`, либо с использованием конструкции `@<имя переменной>`.  
Пример:
```
myfunc =& { afunc 'writeln @funcArgs.0' }
@myfunc 'TEST'
```

Функции могут возвращать результат с помощью команды `return`.  
Пример:
```
func foo, { return 5 }
writeln &foo
# или: writeln 'f foo'
```
Данный код выведет в консоль `5`.
### Объекты и массивы
Каждый объект или массив имеет ID. Также у объекта/массива может быть имя (имя объекта/массива - это переменная, содержащая его ID)

Для получения значения свойства объекта или массива используется оператор `@`: `@<имя объекта или массива>.<имя свойства/индекс>` 
или команды `obj.get <id объекта>, <имя свойства>` для объектов и `arr.get <id массива>, <индекс>` для массивов.

Для установки значения свойства объекта или массива используется конструкция `<имя объекта или массива>.<имя свойства>` 
или команды `obj.set <id объекта>, <имя свойства>, <значение>` для объектов и `arr.set <id массива>, <имя свойства/индекс>, <значение>` для массивов.

У массивов есть свойство `length`, в котором находится длина массива.
### Классы
Класс можно создать с помощью команды `class`. У классов могут быть свойства и методы.  
Свойства записываются с помощью конструкции `<имя свойства> = <значение>`, а методы - `<имя метода>(){ <код метода> }`.  
В коде методов доступна переменная `this`, которая содержит текущий объект.  
Пример создания класса:
```
class Test, {
    str = ''
    constructor(){
        this.str = @funcArgs.0
    }
    setStr(){
        this.str = @funcArgs.0
    }
    printStr(){
        writeln @this.str
    }
}
```

Создать объект из класса можно командой `new`. При этом все свойства и методы будут скопированы из класса. Также будет вызван метод `constructor` (если он есть) с аргументами, переданными команде `new`.  
Пример:
```
obj =& { new Test, 'foo' }
```
### Условия
Условия используются в командах `if`, `ife`, `while`, `for`, `foreach` и `foreachIf`.  
В них можно использовать операторы сравнения: `=` (равно), `<>` (не равно), `<` (меньше), `<=` (меньше или равно), `>` (больше), `>=` (больше или равно),
а также логические операторы: `and` (и), `or` (или), `not` (не).  
Примеры: `if @a < @b, { writeln 'a меньше b' }`
### Скрипты
Скрипты представляют собой текстовые файлы, содержащие команды wesh.  
В скрипты можно вставлять комментарии, начинающиеся с символа `#`. Также все пустые строки игнорируются.  

В скриптах можно использовать многострочные блоки кода.
Пример:
```
for i, 0, 1, 10, {
    writeln 'Команда в блоке кода'
    writeln 'Еще одна команда в блоке кода'
    #комментарий в блоке кода
}
```
### Встроенные переменные
`null` - константа `null`, обозначающая пустой результат.  
`error` - последнее сообщение об ошибке. Если ошибок не было, равняется `@null`.  
`errorAction` - действие при ошибке. Если равно `none`, ошибки будут игнорироваться, если `print`, ошибки будут выводиться в консоль, если `msgbox` - ошибки будут выводиться в окне сообщения. Также можно указать функцию-обработчик ошибок, если присвоить этой переменной значение `func:<имя функции>`.  
`newLine` - символы новой строки (\r\n).  
`currDir` - текущая папка.  
`weshPath` - полный путь к исполняемому файлу wesh.  
`weshDir` - путь к папке расположения wesh.  
`modulesDir` - путь к папке с модулями.  
`modulesUrl` - ссылка на репозиторий модулей. Строка `MODULE_NAME` заменяется именем модуля.
#### Встроенные переменные в скриптах
`scriptPath` - полный путь к скрипту.  
`scriptDir` - путь к папке скрипта.  
`scriptArgs` - массив аргументов скрипта.
### Сокращения типов данных
Эти сокращения могут использоваться в командах `ptr.alloc`, `ptr.sizeof`, `ptr.read`, `ptr.write`, `win32.callDll` и `win32.dllImport`
- `int`: `System.Int32`
- `uint`: `System.UInt32`
- `long`: `System.Int64`
- `ulong`: `System.UInt64`
- `double`: `System.Double`
- `byte`: `System.Byte`
- `intptr`: `System.IntPtr`
- `char`: `System.Char`
- `string`: `System.String`
## Команды
### Общие команды
`exit` - выйти из оболочки.

`echo <строка>` - вернуть указанную строку.

`exec <команда>` - выполнить команду.

`. <выражение>` - вычислить математическое выражение.

`cond <условие>` - вернуть результат условия (`true` или `false`).

`isNull <значение>` - проверить, пустое ли значение передано.

`rand <минимум>, <максимум>` - выдать случайное целое число в указанном диапазоне.

`wait <задержка>` - ждать указанное количество миллисекунд.

`requestAdminPriv` - запросить права администратора. Если они уже получены, ничего не делать.

`try <блок кода 1>, <блок кода 2>` - попытаться выполнить блок кода 1. Если в процессе выполнения произошла ошибка, выполняется блок кода 2. В блоке кода 2 доступна переменная `err`, содержащая сообщение об ошибке. При этом стандартная переменная `error` не устанавливается.

`async <блок кода>` - выполнить блок кода в асинхронном режиме (в отдельном потоке).

`js <блок кода>` - выполнить блок кода на языке JavaScript и вернуть результат его выполнения.

`cs <код>, <режим блока кода>, <точка входа>, <подключаемые сборки>[, <аргументы>]` - выполнить метод с указанными аргументами из кода на языке C#. Если первый аргумент - блок кода, необходимо установить `режим блока кода` в `true`. Точка входа должна иметь формат `className.methodName`. Подключаемые сборки - это список DLL-файлов, разделенных запятыми. Все DLL из этого списка будут загружены.
### Консоль
`write <строка>` - вывести строку в консоль.

`writeln <строка>` - вывести строку в консоль и перейти на новую строку.

`readln <приглашение>` - вывести приглашение в консоль, после чего запросить у пользователя ввод строки в консоль.

`clear` - очистить консоль.

`title <заголовок>` - установить заголовок окна консоли.
### Переменные
`set <имя переменной>, <значение>` или `var.set <имя переменной>, <значение>` - создать переменную или присвоить ей значение.

`sete <имя переменной>, <блок кода>` - присвоить переменной результат выполнения блока кода.

`var.get <имя переменной>` - получить значение переменной.

`var.delete <имя переменной>` - удалить переменную.

`var.list` - вывести имена всех переменных.

`const <имя переменной>` - сделать переменную константой (ее значение нельзя будет изменить).
### Условия и циклы
`if <условие>, <блок кода 1> else <блок кода 2>` - если условие истинно, выполнить блок кода 1, иначе - блок кода 2.

`ife <условие-команда>, <блок кода 1> else <блок кода 2>` - если выполнено условие, выполнить блок кода 1, иначе - блок кода 2. В условии можно использовать операторы `and` (и), `or` (или) и `not` (не). Каждый операнд рассматривается как команда.

`while <условие>, <блок кода>` - пока условие истинно, выполнять блок кода.

`whilee <условие-команда>, <блок кода>` - пока условие истинно, выполнять блок кода. В условии можно использовать операторы `and` (и), `or` (или) и `not` (не). Каждый операнд рассматривается как команда.

`for <имя переменной>, <начальное значение>, <прирост>, <конечное значение>, <блок кода>` - выполнять блок кода, пока значение переменной меньше максимального значения. Переменная создается автоматически и доступна в блоке кода.

`foreach <блок кода 1>, <блок кода 2>` - выполнять блок кода 2 для каждой строки результата выполнения блока кода 1. В блоке кода 2 доступна переменная `s`, в которой находится текущая строка.

`foreachIf <блок кода 1>, <блок кода 2>, <блок кода 3>` - выполнять блок кода 3 для каждой строки результата выполнения блока кода 1, если результат выполнения блока кода 2 - `true`. В блоках кода 2 и 3 доступна переменная `s`, в которой находится текущая строка.
### Функции
`func <название функции>, <блок кода>` - создать функцию.

`f <название функции>[, <аргумент 1>][, <аргумент 2>]...[, <аргумент N>]` - вызвать функцию.
### Объекты
`obj.create <имя объекта>` - создать объект.

`obj.createN <id объекта>` - создать объект с указанным ID.

`obj.get <id объекта>, <имя свойства>` - получить значение свойства объекта.

`obj.set <id объекта>, <имя свойства>, <значение>` - установить значение свойства объекта.

`obj.foreach <id объекта>, <блок кода>` - выполнять блок кода для каждого свойства в объекте. В блоке кода доступны переменные `k` и `v`, содержащие имя свойства и его значение.

`obj.getKeys <id объекта>` - вывести все свойства объекта.

`obj.getData <id объекта>` - вывести все свойства объекта и их значения.

`obj.save <id объекта>, <имя файла>` - сохранить объект в файл.

`obj.load <id объекта>, <имя файла>` - загрузить объект из файла.

`class <имя класса>, <описание класса>` - создать класс.

`new <имя класса>, <аргументы конструктора>` - создать объект из класса.
### Массивы
`arr.create <элемент 1>[, <элемент 2>]...[, <элемент N>]` - создать массив из указанных элементов. Возвращает ID массива.

`arr.get <id массива>, <индекс>` - получить значение элемента массива.

`arr.set <id массива>, <индекс>, <значение>` - установить значение элемента массива.

`arr.push <id массива>, <элемент>` - добавить в конец массива новый элемент. Возвращает длину массива.

`arr.pop <id массива>` - удалить последний элемент массива. Возвращает удаленный элемент.

`arr.shift <id массива>` - удалить первый элемент массива. Возвращает удаленный элемент.

`arr.insert <id массива>, <индекс>, <элемент>` - вставить в массив новый элемент. Возвращает вставленный элемент.

`arr.join <id массива>, <строка>` - объединить элементы массива в строку. Вставляет указанную строку между каждыми 2 элементами.

`barr.readFromFile <имя файла>` - прочитать файл в бинарном режиме и сохранить в массив байт. Возвращает ID массива.

`barr.writeToFile <id массива>, <имя файла>` - записать массив байт в файл.

`barr.toBase64String <id массива>` - перевести указанный массив байт в строку в кодировке Base64.

`barr.fromBase64String <base64-строка>` - перевести указанную строку в кодировке Base64 в массив байт.
### Строки
`str.equals <строка 1>, <строка 2>` - определить, равны ли строки.

`str.contains <строка 1>, <строка 2>` - определить, содержится ли в строке 1 строка 2.

`str.isMatch <строка>, <регулярное выражение>` - определить, соответствует ли строка регулярному выражению.

`str.indexOf <строка>, <символ>` - определить, на какой позиции находится символ в строке.

`str.replace <строка>, <искомая строка>, <замещающая строка>[, <использовать regex>]` - заменить все вхождения в строку искомой строки на замещающую строку. Если `использовать regex` - `true`, искомая строка интерпретируется как регулярное выражение.

`str.concat <строка 1>[, <строка 2>]...[, <строка N>]` - объединить строки в одну.

`str.charAt <строка>, <позиция>` - вернуть символ, находящийся на указанной позиции в строке.

`str.split <строка>, <разделитель>` - разделить указанную строку. Возвращает массив, содержащий фрагменты строки.

`str.toBase64 <строка>` - перевести указанную строку в кодировку Base64.

`str.fromBase64 <base64-строка>` - перевести указанную строку из кодировки Base64.

`str.length <строка>` - получить длину указанной строки.
### Команды
`cmd.list` - вывести все доступные команды.

`cmd.alias <псевдоним>, <имя команды>` - создать псевдоним для команды.

`cmd.fromFunc <имя команды>, <имя функции>` - превратить функцию в команду.
### Модули
`load <модуль 1>[, <модуль 2>]...[, <модуль N>]` - загрузить модули. В качестве имени модуля может использоваться полный путь к файлу, ссылка на файл модуля в Интернете или имя модуля в репозитории.

`module.install <имя модуля>` - установить модуль из репозитория.

`module.uninstall <имя модуля>` - удалить модуль.
### Изменение синтаксиса
`lang.list` - вывести текущие настройки синтаксиса.

`lang.get <элемент>` - получить значение элемента синтаксиса.

`lang.set <элемент>, <значение>` - установить значение элемента синтаксиса.
### Файловая система
`fs.readFile <путь к файлу>` - прочитать файл.

`fs.writeFile <путь к файлу>, <текст>` - записать текст в файл.

`fs.addToFile <путь к файлу>, <текст>` - добавить текст в файл.

`fs.copyFile <путь к файлу>, <новый путь>` - скопировать файл.

`fs.moveFile <путь к файлу>, <новый путь>` - переместить файл.

`fs.deleteFile <путь к файлу>` - удалить файл.

`fs.fileExists <путь к файлу>` - проверить, существует ли файл.

`fs.fileInfo <путь к файлу>` - создать объект со свойствами файла и вернуть его ID.

`cd <путь к папке>` - сменить текущую папку.

`fs.createDir <путь к папке>` - создать папку.

`fs.moveDir <путь к папке>, <новый путь>` - переместить папку.

`fs.deleteDir <путь к папке>` - удалить папку.

`fs.listDir [<путь к папке>][, <режим>][, <полные пути>]` - вернуть список с содержимым папки. Если путь не указан, используется текущая папка. Если `режим` указан и равен `files`, возвращаются только файлы, а если `dirs` - только папки. Если `полные пути` указан и равен `true`, все пути к файлам и папкам будут абсолютными.

`fs.dirExists <путь к папке>` - проверить, существует ли папка.

`fs.dirInfo <путь к папке>` - создать объект со свойствами папки и вернуть его ID.
### Реестр
`reg.createKey <раздел>, <имя нового раздела>` - создать новый раздел в указанном разделе реестра.

`reg.deleteKey <раздел>, <имя удаляемого раздела>` - удалить раздел в указанном разделе реестра.

`reg.list <раздел>` - вывести все подразделы и параметры указанного раздела реестра.

`reg.read <раздел>, <имя параметра>` - прочитать значение параметра реестра.

`reg.write <раздел>, <имя параметра>, <значение>[, <тип значения>]` - установить значение параметра реестра. Допустимые типы значений: `string` (по умолчанию), `expandString`, `multiString`, `binary`, `dWord`, `qWord`, `unknown`, `none`.

`reg.delete <раздел>, <имя параметра>` - удалить параметр из раздела реестра.
### Управление процессами
`proc.run <имя процесса>[, <аргументы>][, <читать stdout>][, <стиль окна>][, <verb>]` - запустить процесс с указанным именем файла и аргументами. Если `читать stdout` - `true`, вернуть данные из StdOut процесса. Допустимые значения для стиля окна - `hidden`, `normal`, `minimized` и `maximized`. Если `verb` указан, использовать его. Возвращает ID процесса, если `читать stdout` не равно `true`.

`proc.kill <id процесса>` - завершить процесс.

`proc.list [<имя процесса>]` - вернуть список всех выполняющихся процессов. Если имя указано, вернуть список всех выполняющихся процессов с указанным именем.

`proc.getInfo <id процесса>` - создать объект со свойствами процесса и вернуть его ID.

`proc.isRunning <id процесса>` - вернуть `true`, если указанный процесс запущен, иначе - `false`.
### Переменные окружения
`env.get <имя переменной>[, <тип>]` - получить значение переменной окружения. Если тип указан и равен `true`, использовать системную переменную, иначе - пользовательскую.

`env.set <имя переменной>, <значение>[, <тип>]` - установить значение переменной окружения. Если тип указан и равен `true`, использовать системную переменную, иначе - пользовательскую.
### HTTP
`http.request <метод>, <URL>[, <тело>]` - выполнить HTTP-запрос и вернуть результат. Доступные методы: `get` и `post`. При использовании метода `post` можно указать тело запроса.

`http.downloadFile <URL>, <путь к файлу>` - скачать файл.

`http.fileServer <путь к папке>, <порт>` - запустить файловый HTTP-сервер с содержимым указанной папки.

`http.server <порт>, <блок кода>` - запустить HTTP-сервер. Блок кода используется в качестве обработчика запросов. В нем доступны переменные `ip`, `url`, `method` и `headers`, содержащие IP клиента, URL, метод и объект с заголовками соответственно. Блок кода должен устанавливать следующие переменные: `statusCode` - код статуса HTTP, `contentType` - MIME-тип контента, и `content` - контент, передаваемый клиенту.

`http.parseUrl <url>` - распарсить URL. Возвращает объект со следующими свойствами: `fullUrl` - полный URL, `path` - полный путь, `query` - объект с GET-параметрами.
### Автоматизация
`proc.activate <id процесса>` - активировать главное окно процесса.

`kb.sendKeys <клавиши>` - отправить активному процессу нажатия клавиш.

`kb.sendKey <код клавиши>` - отправить активному процессу нажатие клавиши.

`mouse.getPos` - создать объект с расположением курсора мыши и вернуть его ID.

`mouse.setPos <x>, <y>` - переместить курсор мыши.

`mouse.click [<кнопка>][, <время>]` - выполнить клик мышью. Допустимые значения кнопки: `left`, `right` и `middle`. По умолчанию - `left`. Время по умолчанию - 10 мс. Если время = 0, не отпускать кнопку.

`hotkey.set <клавиша>, <ctrl>, <alt>, <shift>, <блок кода>` - задать выполнение блока кода при нажатии указанной комбинации клавиш. `ctrl`, `alt` и `shift` могут принимать значения `true` и `false`. Если одно из них равно `true`, блок кода выполнится только при нажатии этой клавиши-модификатора одновременно с основной.

`hotkey.setKeyHandler <блок кода>` - задать выполнение блока кода при нажатии любой клавиши. В блоке кода доступна переменная `key`, содержащая нажатую клавишу.

`hotkey.listen` - запустить цикл прослушивания нажатий клавиш.

`input.sendClick <дескриптор окна>, <кнопка>, <x>, <y>[, <время нажатия>` - отправить окну сообщение о клике мышью в указанных координатах. Допустимые значения для кнопки: `left`, `middle`, `right`. Если время нажатия не указано, кнопка мыши будет отпущена сразу, иначе - будет зажата указанное количество миллисекунд.

`input.sendDoubleClick <дескриптор окна>, <x>, <y>` - отправить окну сообщение о двойном клике левой кнопкой мыши в указанных координатах.

`input.sendMouseMove <дескриптор окна>, <x>, <y>` - отправить окну сообщение о перемещении курсора мыши в указанные координаты.

`input.sendKeyPress <дескриптор окна>, <клавиша>[, <время нажатия>]` - отправить окну сообщение о нажатии указанной клавиши на клавиатуре. Если время нажатия не указано, клавиша будет отпущена сразу, иначе - будет зажата указанное количество миллисекунд. Список кодов клавиш см. в [документации Microsoft](https://learn.microsoft.com/ru-ru/dotnet/api/system.windows.forms.keys?view=windowsdesktop-8.0#----).
### GUI
`msgbox <сообщение>[, <заголовок>][, <кнопки>][, <иконка>]` - отобразить окно сообщения. Допустимые значения кнопок: `ok`, `okCancel`, `yesNo`, `yesNoCancel`, `abortRetryIgnore`, `retryCancel`. Допустимые значения иконки: `none`, `info`, `error`, `warning`, `question`. Возвращает одно из следующих значений в зависимости от выбора пользователя: `none`, `ok`, `cancel`, `yes`, `no`, `abort`, `retry`, `ignore`.

`inputbox <сообщение>, <заголовок>, <текст по умолчанию>` - отобразить окно ввода строки. Возвращает указанную пользователем строку.

`gui.openFileDialog <фильтр>[, <заголовок>][, <папка>]` - открыть диалоговое окно открытия файла и вернуть путь к выбранному пользователем файлу.

`gui.saveFileDialog <фильтр>[, <заголовок>][, <папка>]` - открыть диалоговое окно сохранения файла и вернуть путь к выбранному пользователем файлу.

`gui.createForm <заголовок>, <длина>, <ширина>[, <фиксированный размер>]` - создать форму и вернуть ее ID.

`gui.showForm <id формы>` - отобразить форму.

`gui.createElem <тип>, <x>, <y>, <длина>, <ширина>` - создать элемент GUI и вернуть его ID. Допустимые типы: `panel`, `label`, `button`, `textbox`, `checkbox`, `combobox`.

`gui.getElemProp <id формы/элемента>, <имя свойства>` - получить значение свойства элемента или формы. Допустимые свойства: `text`, `x`, `y`, `width`, `height`, `color` (в формате `R,G,B`), bgcolor (в формате `R,G,B`), `checked` (только для `checkbox`), `multiline` (только для `textbox`).

`gui.setElemProp <id формы/элемента>, <имя свойства>, <значение>` - установить значение свойства элемента или формы. Допустимые свойства: `text`, `x`, `y`, `width`, `height`, `color` (в формате `R,G,B`), bgcolor (в формате `R,G,B`), `checked` (только для `checkbox`), `multiline` (только для `textbox`).

`gui.setFont <id формы/элемента>, <имя шрифта>, <размер шрифта>` - установить шрифт элемента или формы.

`gui.addEvent <id формы/элемента>, <тип события>, <блок кода>` - добавить обработчик события для элемента или формы. Допустимые типы: `click` и `keydown`. Если тип - `keydown`, в блоке кода доступна переменная `key`, содержащая нажатую клавишу.

`gui.addElem <id формы/панели>, <id элемента>` - добавить элемент в форму/на панель.

`gui.getElemHandle <id формы/элемента>` - получить дескриптор формы/элемента.
### Win32
`win32.getHandle <значение>` - получить дескриптор окна по его числовому значению (полученному, например, из Spy++).

`win32.getHandleValue <дескриптор>` - получить числовое значение дескриптора окна.

`win32.findWindow <класс>, <текст>` - найти окно по классу или тексту. Возвращает ID дескриптора окна. Класс или текст могут быть равны `@null`. Подробнее: [FindWindow](https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-findwindowa)

`win32.findChildWindow <дескриптор родительского окна>, <класс>, <текст>` - найти дочернее окно. Возвращает ID дескриптора окна. Класс или текст могут быть равны `@null`. Подробнее: [FindWindowEx](https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-findwindowexa)

`win32.getForegroundWindow` - вернуть ID дескриптора активного окна.

`win32.sendMessage <дескриптор>, <сообщение>, <wParam>, <lParam>` - отправить сообщение окну. Подробнее: [SendMessage](https://learn.microsoft.com/ru-ru/windows/win32/api/winuser/nf-winuser-sendmessage)

`win32.getWindowText <дескриптор окна>` - получить текст из указанного окна.

`win32.setWindowText <дескриптор окна>, <текст>` - задает текст в указанном окне.

`win32.enumWindows <блок кода>` - запустить блок кода для каждого открытого окна. В блоке кода боступна переменная `wnd`, содержащая дескриптор текущего окна.

`win32.getWindowPos <дескриптор окна>` - получить позицию и размер окна. Возвращает объект со следующими свойствами: `x` - положение окна по X, `y` - положение окна по Y, `width` - длина окна, `height` - ширина окна.

`win32.setWindowPos <дескриптор окна>, <x>, <y>[, <длина>][, <ширина>]` - установить позицию и (необязательно) размер окна.

`win32.callDll <путь к dll>, <имя или номер функции>, <тип возвращаемого значения>, <аргументы>` - вызвать функцию из DLL и вернуть результат ее выполнения. Если DLL находится в одной из папок, указанных в `%PATH%`, то можно не указывать путь и расширение `.dll`. Если функция вызывается по номеру, перед ним необходимо использовать префикс `#`. Аргументы передаются в формате `<тип>:<значение>`.

`win32.dllImport <имя команды>, <путь к dll>, <имя или номер функции>, <тип возвращаемого значения>, <типы аргументов>` - импортировать функцию из DLL и создать команду с указанным именем. Если DLL находится в одной из папок, указанных в `%PATH%`, то можно не указывать путь и расширение `.dll`. Если имя не указано, создается команда с именем `<путь к dll>/<имя или номер функции>`. Если функция вызывается по номеру, перед ним необходимо использовать префикс `#`.
### Буфер обмена
`clipboard.get` - получить текст из буфера обмена.

`clipboard.set <текст>` - вставить текст в буфер обмена.
### ZIP-архивы
`zip.create <папка>, <zip-файл>` - упаковать указанную папку в ZIP-файл.

`zip.extract <zip-файл>, <папка>` - распаковать ZIP-файл в указанную папку.
### Указатели
`ptr.alloc <размер или тип>` - выделить память в куче. Если указано число, выделяется указанное количество байт, а если указан тип - количество байт, равное размеру данного типа. Возвращает ID указателя.

`ptr.free <id указателя>` - освободить память в куче.

`ptr.read <id указателя>, <тип>[, <смещение>]` - прочитать и вернуть значение указанного типа из памяти, добавив указанное смещение к адресу указателя.

`ptr.write <id указателя>, <тип>, <смещение>, <значение>` - записать значение указанного типа в память, добавив указанное смещение к адресу указателя.

`ptr.getValue <id указателя>` - получить числовое значение указателя.

`ptr.sizeof <тип>` - получить размер указанного типа в байтах.

`ptr.getAnsiString <id указателя>` - прочитать ANSI-строку из памяти.

`ptr.putAnsiString <строка>` - записать ANSI-строку в память. Возвращает ID указателя.

`ptr.getUnicodeString <id указателя>` - прочитать Unicode-строку из памяти.

`ptr.putUnicodeString <строка>` - записать Unicode-строку в память. Возвращает ID указателя.
### Аудио
`audio.open <файл>` - открыть указанный аудио-файл. Возвращает ID проигрывателя.

`audio.close <id проигрывателя>` - закрыть указанный аудио-файл.

`audio.play <id проигрывателя>[, <флаг>]` - начать воспроизведение указанного аудио-файла. Подробнее о флагах см. в [документации Microsoft](https://learn.microsoft.com/en-us/windows/win32/multimedia/play).

`audio.stop <id проигрывателя>` - остановить воспроизведение указанного аудио-файла.

`audio.pause <id проигрывателя>` - приостановить воспроизведение указанного аудио-файла.

`audio.resume <id проигрывателя>` - возобновить воспроизведение указанного аудио-файла.

`audio.sendMCI <команда>` - отправить команду [MCI](https://learn.microsoft.com/en-us/windows/win32/multimedia/multimedia-command-strings).
### Объекты-расширения
`eobj.createCOMObject <ProgId>` - создать экземпляр COM-объекта по его ProgId. Возвращает ID объекта.

`eobj.loadNETAssembly <сборка>` - загрузить указанную сборку .NET.

`eobj.createNETObject <тип>[, <аргументы конструктора>]` - создать экземпляр .NET-объекта по его типу. Возвращает ID объекта.

`eobj.getNETClass <тип>` - получить .NET-класс. Возвращает ID объекта.

`eobj.getProp <id объекта>, <свойство>` - получить значение указанного свойства объекта-расширения.

`eobj.setProp <id объекта>, <свойство>, <значение>` - установить значение указанного свойства объекта-расширения.

`eobj.invokeMethod <id объекта>, <метод>[, <аргументы>]` - вызвать указанный метод объекта-расширения-расширения.
